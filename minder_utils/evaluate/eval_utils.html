<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>minder_utils.evaluate.eval_utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>minder_utils.evaluate.eval_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from sklearn.metrics import f1_score, accuracy_score
from sklearn.metrics import confusion_matrix
import numpy as np
from sklearn.model_selection import train_test_split, StratifiedKFold
from ..formatting.format_util import y_to_categorical


def get_scores(y_true, y_pred):
    if y_true.ndim &gt; 1:
        y_true = np.argmax(y_true, axis=1)
    if y_pred.ndim &gt; 1:
        y_pred = np.argmax(y_pred, axis=1)
    try:
        tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
    except ValueError:
        return None, None, None, None
    specificity = tn / (tn + fp)
    sensitivity = tp / (tp + fn)

    acc = accuracy_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred)
    return sensitivity, specificity, acc, f1


def split_by_ids(X, y, patient_ids, cat=True, valid_only=True, stratify=True, seed=0):
    y[y == 0] = -1
    y = y.reshape(-1, )
    patient_ids = patient_ids.reshape(-1, )
    # make sure the train and test set got both positive and negative patients
    y_p_id = []
    for p_id in np.unique(patient_ids):
        _y = np.unique(y[patient_ids == p_id])
        rng = np.random.default_rng(seed)
        y_p_id.append(int(_y[0]) if len(_y) &lt; 2 else rng.integers(0,2))
        seed += 1
    y_p_id = np.array(y_p_id)
    y_p_id[y_p_id &lt; 0] = 0

    train_ids, test_ids = train_test_split(np.unique(patient_ids), test_size=0.33, random_state=seed, stratify=y_p_id if stratify else None)
    test_y = y[np.isin(patient_ids, test_ids)]
    if valid_only:
        test_filter = np.isin(test_y, [-1, 1])
    else:
        test_filter = np.isin(test_y, np.unique(test_y))
    if cat:
        return X[np.isin(patient_ids, train_ids)], y_to_categorical(y[np.isin(patient_ids, train_ids)]), \
               X[np.isin(patient_ids, test_ids)][test_filter], y_to_categorical(y[np.isin(patient_ids, test_ids)][
                   test_filter])
    return X[np.isin(patient_ids, train_ids)], y[np.isin(patient_ids, train_ids)], \
           X[np.isin(patient_ids, test_ids)], y[np.isin(patient_ids, test_ids)]



class StratifiedKFoldPids:
    def __init__(self, n_splits=5, shuffle=False, random_state=None):
        &#39;&#39;&#39;
        This splits the data so that no train and test 
        split contain the same pid. They will contain 
        roughly the same number of positive 
        and negative samples.

        This is based on: It will function in the same way.
        https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html


        Arguments
        ---------
        
        - ```n_splits```: ```int```, optional:
            The number of splits. 
            Defaults to ```5```.
        
        - ```shuffle```: ```bool```, optional:
            Whether to shuffle the order of the pids before 
            making the splits. 
            Defaults to ```False```.
        
        - ```random_state```: ```_type_```, optional:
            The random state for the random processes in the class. 
            Defaults to ```None```.
        
        
        
        
        &#39;&#39;&#39;
        self.n_splits = n_splits
        self.shuffle = shuffle
        self.random_state = random_state
        return


    def get_n_splits(self):
        &#39;&#39;&#39;
        Returns the number of splits
        

        Returns
        --------
        
        - ```out```: ```int``` : 
            The number of splits
        
        
        &#39;&#39;&#39;
        return self.n_splits


    def split_by_ids(self, y, pids, seed=0):
        &#39;&#39;&#39;
        An internal function that given a set of 
        labels and PIDs corresponding to the labels,
        this function can return the pid values that
        should be assigned to the training or testing 
        set for each split.
        
        
        
        Arguments
        ---------
        
        - ```y```: ```array```: 
            Labels.
        
        - ```pids```: ```array```: 
            PIDs corresponding to ```y```.
        
        - ```seed```: ```int```, optional:
            The random seed for the random processes. 
            Defaults to ```0```.
        
        
        
        Returns
        --------
        
        - ```out```: ```_type_``` : 
            PID values that should be assigned 
            to the training or testing set for each split.
        
        
        &#39;&#39;&#39;
        labels = np.copy(y)
        labels[labels == 0] = -1
        labels = labels.reshape(-1, )
        pids = pids.reshape(-1, )
        # make sure the train and test set got both positive and negative patients
        y_p_id = []
        for p_id in np.unique(pids):
            _y = np.unique(y[pids == p_id])
            rng = np.random.default_rng(seed)
            y_p_id.append(int(_y[0]) if len(_y) &lt; 2 else rng.integers(0,2))
            seed += 1
        y_p_id = np.array(y_p_id)
        y_p_id[y_p_id &lt; 0] = 0
        splitter = StratifiedKFold(n_splits=self.n_splits, 
                                    shuffle=self.shuffle, 
                                    random_state=seed if self.shuffle else None)
        splits = list(splitter.split(np.unique(pids), y=y_p_id))
        return [[np.unique(pids)[train_idx], np.unique(pids)[test_idx]] for train_idx, test_idx in splits]


    def split(self, X, y, pids):
        &#39;&#39;&#39;
        This function produces the splits that can be used for training 
        and testing.
        
        
        
        Arguments
        ---------
        
        - ```X```: ```array```: 
            X input. This isn&#39;t used and so anything can be passed here.
        
        - ```y```: ```array```: 
            The labels. This is used to stratify the data.
        
        - ```pids```: ```_type_```: 
            The PIDs that is used to split the data.
        
        
        
        Returns
        --------
        
        - ```out```: ```list``` : 
            List of train-test splits. This 
            list has length equal to ```n_splits```.
        
        
        &#39;&#39;&#39;
        rng = np.random.default_rng(self.random_state)
        seed = rng.integers(0,1e6)
        list_of_splits_pids = self.split_by_ids(y=y, pids=pids, seed=seed)
        list_of_splits = []
        for train_pids, test_pids in list_of_splits_pids:
            
            train_idx_new = np.arange(len(pids))[np.isin(pids, train_pids)]
            test_idx_new = np.arange(len(pids))[np.isin(pids, test_pids)]

            list_of_splits.append([
                train_idx_new,
                test_idx_new,
            ])
            
        return list_of_splits</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="minder_utils.evaluate.eval_utils.get_scores"><code class="name flex">
<span>def <span class="ident">get_scores</span></span>(<span>y_true, y_pred)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scores(y_true, y_pred):
    if y_true.ndim &gt; 1:
        y_true = np.argmax(y_true, axis=1)
    if y_pred.ndim &gt; 1:
        y_pred = np.argmax(y_pred, axis=1)
    try:
        tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
    except ValueError:
        return None, None, None, None
    specificity = tn / (tn + fp)
    sensitivity = tp / (tp + fn)

    acc = accuracy_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred)
    return sensitivity, specificity, acc, f1</code></pre>
</details>
</dd>
<dt id="minder_utils.evaluate.eval_utils.split_by_ids"><code class="name flex">
<span>def <span class="ident">split_by_ids</span></span>(<span>X, y, patient_ids, cat=True, valid_only=True, stratify=True, seed=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_by_ids(X, y, patient_ids, cat=True, valid_only=True, stratify=True, seed=0):
    y[y == 0] = -1
    y = y.reshape(-1, )
    patient_ids = patient_ids.reshape(-1, )
    # make sure the train and test set got both positive and negative patients
    y_p_id = []
    for p_id in np.unique(patient_ids):
        _y = np.unique(y[patient_ids == p_id])
        rng = np.random.default_rng(seed)
        y_p_id.append(int(_y[0]) if len(_y) &lt; 2 else rng.integers(0,2))
        seed += 1
    y_p_id = np.array(y_p_id)
    y_p_id[y_p_id &lt; 0] = 0

    train_ids, test_ids = train_test_split(np.unique(patient_ids), test_size=0.33, random_state=seed, stratify=y_p_id if stratify else None)
    test_y = y[np.isin(patient_ids, test_ids)]
    if valid_only:
        test_filter = np.isin(test_y, [-1, 1])
    else:
        test_filter = np.isin(test_y, np.unique(test_y))
    if cat:
        return X[np.isin(patient_ids, train_ids)], y_to_categorical(y[np.isin(patient_ids, train_ids)]), \
               X[np.isin(patient_ids, test_ids)][test_filter], y_to_categorical(y[np.isin(patient_ids, test_ids)][
                   test_filter])
    return X[np.isin(patient_ids, train_ids)], y[np.isin(patient_ids, train_ids)], \
           X[np.isin(patient_ids, test_ids)], y[np.isin(patient_ids, test_ids)]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="minder_utils.evaluate.eval_utils.StratifiedKFoldPids"><code class="flex name class">
<span>class <span class="ident">StratifiedKFoldPids</span></span>
<span>(</span><span>n_splits=5, shuffle=False, random_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This splits the data so that no train and test
split contain the same pid. They will contain
roughly the same number of positive
and negative samples.</p>
<p>This is based on: It will function in the same way.
<a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html">https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html</a></p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>
<p><code>n_splits</code>: <code>int</code>, optional:
The number of splits.
Defaults to <code>5</code>.</p>
</li>
<li>
<p><code>shuffle</code>: <code>bool</code>, optional:
Whether to shuffle the order of the pids before
making the splits.
Defaults to <code>False</code>.</p>
</li>
<li>
<p><code>random_state</code>: <code>_type_</code>, optional:
The random state for the random processes in the class.
Defaults to <code>None</code>.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StratifiedKFoldPids:
    def __init__(self, n_splits=5, shuffle=False, random_state=None):
        &#39;&#39;&#39;
        This splits the data so that no train and test 
        split contain the same pid. They will contain 
        roughly the same number of positive 
        and negative samples.

        This is based on: It will function in the same way.
        https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html


        Arguments
        ---------
        
        - ```n_splits```: ```int```, optional:
            The number of splits. 
            Defaults to ```5```.
        
        - ```shuffle```: ```bool```, optional:
            Whether to shuffle the order of the pids before 
            making the splits. 
            Defaults to ```False```.
        
        - ```random_state```: ```_type_```, optional:
            The random state for the random processes in the class. 
            Defaults to ```None```.
        
        
        
        
        &#39;&#39;&#39;
        self.n_splits = n_splits
        self.shuffle = shuffle
        self.random_state = random_state
        return


    def get_n_splits(self):
        &#39;&#39;&#39;
        Returns the number of splits
        

        Returns
        --------
        
        - ```out```: ```int``` : 
            The number of splits
        
        
        &#39;&#39;&#39;
        return self.n_splits


    def split_by_ids(self, y, pids, seed=0):
        &#39;&#39;&#39;
        An internal function that given a set of 
        labels and PIDs corresponding to the labels,
        this function can return the pid values that
        should be assigned to the training or testing 
        set for each split.
        
        
        
        Arguments
        ---------
        
        - ```y```: ```array```: 
            Labels.
        
        - ```pids```: ```array```: 
            PIDs corresponding to ```y```.
        
        - ```seed```: ```int```, optional:
            The random seed for the random processes. 
            Defaults to ```0```.
        
        
        
        Returns
        --------
        
        - ```out```: ```_type_``` : 
            PID values that should be assigned 
            to the training or testing set for each split.
        
        
        &#39;&#39;&#39;
        labels = np.copy(y)
        labels[labels == 0] = -1
        labels = labels.reshape(-1, )
        pids = pids.reshape(-1, )
        # make sure the train and test set got both positive and negative patients
        y_p_id = []
        for p_id in np.unique(pids):
            _y = np.unique(y[pids == p_id])
            rng = np.random.default_rng(seed)
            y_p_id.append(int(_y[0]) if len(_y) &lt; 2 else rng.integers(0,2))
            seed += 1
        y_p_id = np.array(y_p_id)
        y_p_id[y_p_id &lt; 0] = 0
        splitter = StratifiedKFold(n_splits=self.n_splits, 
                                    shuffle=self.shuffle, 
                                    random_state=seed if self.shuffle else None)
        splits = list(splitter.split(np.unique(pids), y=y_p_id))
        return [[np.unique(pids)[train_idx], np.unique(pids)[test_idx]] for train_idx, test_idx in splits]


    def split(self, X, y, pids):
        &#39;&#39;&#39;
        This function produces the splits that can be used for training 
        and testing.
        
        
        
        Arguments
        ---------
        
        - ```X```: ```array```: 
            X input. This isn&#39;t used and so anything can be passed here.
        
        - ```y```: ```array```: 
            The labels. This is used to stratify the data.
        
        - ```pids```: ```_type_```: 
            The PIDs that is used to split the data.
        
        
        
        Returns
        --------
        
        - ```out```: ```list``` : 
            List of train-test splits. This 
            list has length equal to ```n_splits```.
        
        
        &#39;&#39;&#39;
        rng = np.random.default_rng(self.random_state)
        seed = rng.integers(0,1e6)
        list_of_splits_pids = self.split_by_ids(y=y, pids=pids, seed=seed)
        list_of_splits = []
        for train_pids, test_pids in list_of_splits_pids:
            
            train_idx_new = np.arange(len(pids))[np.isin(pids, train_pids)]
            test_idx_new = np.arange(len(pids))[np.isin(pids, test_pids)]

            list_of_splits.append([
                train_idx_new,
                test_idx_new,
            ])
            
        return list_of_splits</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="minder_utils.evaluate.eval_utils.StratifiedKFoldPids.get_n_splits"><code class="name flex">
<span>def <span class="ident">get_n_splits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of splits</p>
<h2 id="returns">Returns</h2>
<ul>
<li><code>out</code>: <code>int</code> :
The number of splits</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_splits(self):
    &#39;&#39;&#39;
    Returns the number of splits
    

    Returns
    --------
    
    - ```out```: ```int``` : 
        The number of splits
    
    
    &#39;&#39;&#39;
    return self.n_splits</code></pre>
</details>
</dd>
<dt id="minder_utils.evaluate.eval_utils.StratifiedKFoldPids.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, X, y, pids)</span>
</code></dt>
<dd>
<div class="desc"><p>This function produces the splits that can be used for training
and testing.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>
<p><code>X</code>: <code>array</code>:
X input. This isn't used and so anything can be passed here.</p>
</li>
<li>
<p><code>y</code>: <code>array</code>:
The labels. This is used to stratify the data.</p>
</li>
<li>
<p><code>pids</code>: <code>_type_</code>:
The PIDs that is used to split the data.</p>
</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li><code>out</code>: <code>list</code> :
List of train-test splits. This
list has length equal to <code>n_splits</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, X, y, pids):
    &#39;&#39;&#39;
    This function produces the splits that can be used for training 
    and testing.
    
    
    
    Arguments
    ---------
    
    - ```X```: ```array```: 
        X input. This isn&#39;t used and so anything can be passed here.
    
    - ```y```: ```array```: 
        The labels. This is used to stratify the data.
    
    - ```pids```: ```_type_```: 
        The PIDs that is used to split the data.
    
    
    
    Returns
    --------
    
    - ```out```: ```list``` : 
        List of train-test splits. This 
        list has length equal to ```n_splits```.
    
    
    &#39;&#39;&#39;
    rng = np.random.default_rng(self.random_state)
    seed = rng.integers(0,1e6)
    list_of_splits_pids = self.split_by_ids(y=y, pids=pids, seed=seed)
    list_of_splits = []
    for train_pids, test_pids in list_of_splits_pids:
        
        train_idx_new = np.arange(len(pids))[np.isin(pids, train_pids)]
        test_idx_new = np.arange(len(pids))[np.isin(pids, test_pids)]

        list_of_splits.append([
            train_idx_new,
            test_idx_new,
        ])
        
    return list_of_splits</code></pre>
</details>
</dd>
<dt id="minder_utils.evaluate.eval_utils.StratifiedKFoldPids.split_by_ids"><code class="name flex">
<span>def <span class="ident">split_by_ids</span></span>(<span>self, y, pids, seed=0)</span>
</code></dt>
<dd>
<div class="desc"><p>An internal function that given a set of
labels and PIDs corresponding to the labels,
this function can return the pid values that
should be assigned to the training or testing
set for each split.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>
<p><code>y</code>: <code>array</code>:
Labels.</p>
</li>
<li>
<p><code>pids</code>: <code>array</code>:
PIDs corresponding to <code>y</code>.</p>
</li>
<li>
<p><code>seed</code>: <code>int</code>, optional:
The random seed for the random processes.
Defaults to <code>0</code>.</p>
</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li><code>out</code>: <code>_type_</code> :
PID values that should be assigned
to the training or testing set for each split.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_by_ids(self, y, pids, seed=0):
    &#39;&#39;&#39;
    An internal function that given a set of 
    labels and PIDs corresponding to the labels,
    this function can return the pid values that
    should be assigned to the training or testing 
    set for each split.
    
    
    
    Arguments
    ---------
    
    - ```y```: ```array```: 
        Labels.
    
    - ```pids```: ```array```: 
        PIDs corresponding to ```y```.
    
    - ```seed```: ```int```, optional:
        The random seed for the random processes. 
        Defaults to ```0```.
    
    
    
    Returns
    --------
    
    - ```out```: ```_type_``` : 
        PID values that should be assigned 
        to the training or testing set for each split.
    
    
    &#39;&#39;&#39;
    labels = np.copy(y)
    labels[labels == 0] = -1
    labels = labels.reshape(-1, )
    pids = pids.reshape(-1, )
    # make sure the train and test set got both positive and negative patients
    y_p_id = []
    for p_id in np.unique(pids):
        _y = np.unique(y[pids == p_id])
        rng = np.random.default_rng(seed)
        y_p_id.append(int(_y[0]) if len(_y) &lt; 2 else rng.integers(0,2))
        seed += 1
    y_p_id = np.array(y_p_id)
    y_p_id[y_p_id &lt; 0] = 0
    splitter = StratifiedKFold(n_splits=self.n_splits, 
                                shuffle=self.shuffle, 
                                random_state=seed if self.shuffle else None)
    splits = list(splitter.split(np.unique(pids), y=y_p_id))
    return [[np.unique(pids)[train_idx], np.unique(pids)[test_idx]] for train_idx, test_idx in splits]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Minder Utils" href="https://minder-utils.github.io">
<img src="https://github.com/ImperialCollegeLondon/minder_utils/blob/main/UKDRI_logo.jpeg?raw=true" alt=""> Minder Utils
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="minder_utils.evaluate" href="index.html">minder_utils.evaluate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="minder_utils.evaluate.eval_utils.get_scores" href="#minder_utils.evaluate.eval_utils.get_scores">get_scores</a></code></li>
<li><code><a title="minder_utils.evaluate.eval_utils.split_by_ids" href="#minder_utils.evaluate.eval_utils.split_by_ids">split_by_ids</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="minder_utils.evaluate.eval_utils.StratifiedKFoldPids" href="#minder_utils.evaluate.eval_utils.StratifiedKFoldPids">StratifiedKFoldPids</a></code></h4>
<ul class="">
<li><code><a title="minder_utils.evaluate.eval_utils.StratifiedKFoldPids.get_n_splits" href="#minder_utils.evaluate.eval_utils.StratifiedKFoldPids.get_n_splits">get_n_splits</a></code></li>
<li><code><a title="minder_utils.evaluate.eval_utils.StratifiedKFoldPids.split" href="#minder_utils.evaluate.eval_utils.StratifiedKFoldPids.split">split</a></code></li>
<li><code><a title="minder_utils.evaluate.eval_utils.StratifiedKFoldPids.split_by_ids" href="#minder_utils.evaluate.eval_utils.StratifiedKFoldPids.split_by_ids">split_by_ids</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>